import categoriesData from "../../../data/v2/categories.json";
import emergencyData from "../../../data/v2/emergency.json";
import heuristicsData from "../../../data/v2/heuristics.json";
import servicesData from "../../../data/v2/services.json";
import flowSpecRegistry from "../../../../docs/domain/flows-v2-spec.json";
import type { FlowSpecV2 } from "../../contracts/flowSpecV2";
import { buildRuntimeV2ById } from "../../flows/runtimeV2";
import { toLegacyFlow } from "../../flows/toLegacyUI";
import type { AppModel, Category, Flow, RiskGroup, Service } from "../../../types";
import { flowRegistry } from "../../../registry/flowRegistry";

interface RawCategory {
  id?: unknown;
  label?: unknown;
  riskGroup?: unknown;
  icon?: unknown;
  color?: unknown;
  weight?: unknown;
  description?: unknown;
  isEmergencyCategory?: unknown;
  subcategories?: unknown;
}

interface SpecRegistryFlow {
  id: string;
  categoryId: string;
  subcategoryId: string;
  status: string;
  severity: "CRITICAL" | "HIGH" | "MODERATE";
}

interface SpecRegistry {
  flows: SpecRegistryFlow[];
  draftFlowSpecs?: unknown[];
}

interface ServicesPayload {
  services?: Service[];
}

const ALLOWED_RISK_GROUPS = new Set<RiskGroup>([
  "violence",
  "psychosocial",
  "medical",
  "social",
  "rights",
  "structural",
  "emergency",
]);


const OFFICIAL_CATEGORY_IDS = [
  "emergencias_seguranca",
  "saude_bem_estar",
  "saude_emocional",
  "convivencia_conflitos",
  "protecao_direitos",
  "apoio_social_familiar",
  "inclusao_acessibilidade",
] as const;

function buildBaseModelV2(): Omit<AppModel, "categories" | "services" | "flows"> {
  const emergency = emergencyData as {
    enabled?: boolean;
    priorityRouteIds?: string[];
  };

  return {
    version: "1.0.0",
    meta: {
      appName: "Protocolo Bússola",
      version: "1.0",
      scope: "MVP Consulta",
      guardrailEnabled: true,
      emergencyButton: emergency.enabled
        ? {
            label: "Emergência",
            color: "red",
            fixed: true,
            priorityRouteIds: Array.isArray(emergency.priorityRouteIds)
              ? emergency.priorityRouteIds
              : [],
          }
        : undefined,
    },
    searchConfig: {
      mode: "direct-to-subcategory",
      includeSynonyms: true,
      fieldsIndexed: ["meta.title", "meta.subcategory", "triage.questions.text"],
    },
    uiConfig: {
      designStyle: "clean_glassmorphism_light",
      cardsRounded: true,
      shadowSoft: true,
      maxQuestionsPerFlow: 6,
      resultLayout: {
        primaryServiceFirst: true,
        secondaryServiceVisible: true,
        collapsibleGuidelines: true,
        institutionalSummaryAutoGenerated: true,
      },
    },
    guardrail: {
      questions: [],
    },
    orientationBlocks: [],
    summaryTemplate: {
      title: "Resumo Institucional",
      structure: [],
    },
    institution: {
      name: "Instituição",
      managementContact: {
        name: "Gestão Escolar",
        phone: "",
        email: "",
      },
    },
  };
}

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null;
}

function isString(value: unknown): value is string {
  return typeof value === "string" && value.trim().length > 0;
}

function ensureRecord(value: unknown, message: string): Record<string, unknown> {
  if (!isRecord(value)) {
    throw new Error(message);
  }
  return value;
}

function ensureString(value: unknown, message: string): string {
  if (!isString(value)) {
    throw new Error(message);
  }
  return value.trim();
}

function parseCategories(raw: unknown): Category[] {
  if (!Array.isArray(raw)) {
    throw new Error("src/data/v2/categories.json invalido: esperado array de categorias.");
  }

  return raw.map((item, index) => {
    const cat = item as RawCategory;

    const id = ensureString(cat.id, `Categoria[${index}] invalida: "id" obrigatorio.`);
    const label = ensureString(cat.label, `Categoria "${id}" invalida: "label" obrigatorio.`);
    const icon = ensureString(cat.icon, `Categoria "${id}" invalida: "icon" obrigatorio.`);
    const riskGroup = ensureString(
      cat.riskGroup,
      `Categoria "${id}" invalida: "riskGroup" obrigatorio.`
    ) as RiskGroup;

    if (!ALLOWED_RISK_GROUPS.has(riskGroup)) {
      throw new Error(`Categoria "${id}" invalida: riskGroup "${riskGroup}" nao suportado.`);
    }

    const rawSubcategories = Array.isArray(cat.subcategories) ? cat.subcategories : [];

    const subcategories = rawSubcategories.map((sub, subIndex) => {
      const subRecord = ensureRecord(
        sub,
        `Categoria "${id}" invalida: subcategory[${subIndex}] deve ser objeto.`
      );

      return {
        id: ensureString(
          subRecord.id,
          `Categoria "${id}" invalida: subcategory[${subIndex}].id obrigatorio.`
        ),
        label: ensureString(
          subRecord.label,
          `Categoria "${id}" invalida: subcategory[${subIndex}].label obrigatorio.`
        ),
      };
    });

    return {
      id,
      label,
      icon,
      riskGroup,
      color: isString(cat.color) ? cat.color : undefined,
      weight: typeof cat.weight === "number" ? cat.weight : undefined,
      description: isString(cat.description) ? cat.description : undefined,
      isEmergencyCategory: Boolean(cat.isEmergencyCategory),
      subcategories,
    };
  });
}

function buildCategoriesFromRegistry(
  parsedCategories: Category[],
  registryFlows: SpecRegistryFlow[]
): Category[] {
  const byId = new Map(parsedCategories.map(category => [category.id, category]));

  const categoryIdsInRegistry = Array.from(new Set(registryFlows.map(flow => flow.categoryId)));

  if (categoryIdsInRegistry.length !== OFFICIAL_CATEGORY_IDS.length) {
    throw new Error(
      `Categorias invalidas: esperado ${OFFICIAL_CATEGORY_IDS.length}, recebido ${categoryIdsInRegistry.length}.`
    );
  }

  OFFICIAL_CATEGORY_IDS.forEach((id, index) => {
    if (categoryIdsInRegistry[index] !== id) {
      throw new Error(`Categorias invalidas: ordem/id divergente no registry para "${id}".`);
    }
  });

  return OFFICIAL_CATEGORY_IDS.map((categoryId, orderIndex) => {
    const baseCategory = byId.get(categoryId);
    if (!baseCategory) {
      throw new Error(`Categoria oficial ausente em src/data/v2/categories.json: "${categoryId}".`);
    }

    const knownSubLabelById = new Map(baseCategory.subcategories.map(sub => [sub.id, sub.label]));
    const usedSubcategories = registryFlows
      .filter(flow => flow.categoryId === categoryId)
      .map(flow => flow.subcategoryId)
      .filter((subId, index, arr) => arr.indexOf(subId) === index)
      .map(subId => ({
        id: subId,
        label: knownSubLabelById.get(subId) || subId,
      }));

    return {
      ...baseCategory,
      weight:
        typeof baseCategory.weight === "number"
          ? baseCategory.weight
          : (baseCategory.isEmergencyCategory ? 100 : OFFICIAL_CATEGORY_IDS.length - orderIndex),
      subcategories: usedSubcategories,
    };
  });
}

function buildCategorySubIndex(categories: Category[]): Map<string, Set<string>> {
  const index = new Map<string, Set<string>>();

  for (const category of categories) {
    if (index.has(category.id)) {
      throw new Error(`Categorias invalidas: categoryId duplicado "${category.id}".`);
    }

    const subIds = new Set<string>();
    for (const sub of category.subcategories) {
      if (subIds.has(sub.id)) {
        throw new Error(
          `Categorias invalidas: subcategoryId duplicado "${sub.id}" em "${category.id}".`
        );
      }
      subIds.add(sub.id);
    }

    index.set(category.id, subIds);
  }

  return index;
}

function validateFlowSpec(flow: FlowSpecV2, index: number): void {
  if (!isRecord(flow.meta)) {
    throw new Error(`FlowSpec[${index}] invalido: meta ausente.`);
  }

  ensureString(flow.meta.id, `FlowSpec[${index}] invalido: meta.id obrigatorio.`);
  ensureString(flow.meta.categoryId, `FlowSpec[${index}] invalido: meta.categoryId obrigatorio.`);
  ensureString(
    flow.meta.subcategoryId,
    `FlowSpec[${index}] invalido: meta.subcategoryId obrigatorio.`
  );
  ensureString(flow.meta.title, `FlowSpec[${index}] invalido: meta.title obrigatorio.`);
  ensureString(flow.meta.description, `FlowSpec[${index}] invalido: meta.description obrigatorio.`);

  if (!Array.isArray(flow.meta.keywords)) {
    throw new Error(`FlowSpec "${flow.meta.id}" invalido: meta.keywords deve ser array.`);
  }

  if (!Array.isArray(flow.steps)) {
    throw new Error(`FlowSpec "${flow.meta.id}" invalido: steps deve ser array.`);
  }

  if (!Array.isArray(flow.outcomes)) {
    throw new Error(`FlowSpec "${flow.meta.id}" invalido: outcomes deve ser array.`);
  }

  for (const step of flow.steps) {
    if (!step || !isString(step.id)) {
      throw new Error(`FlowSpec "${flow.meta.id}" invalido: step.id obrigatorio.`);
    }

    if (
      step.type !== "alert" &&
      step.type !== "question" &&
      step.type !== "action"
    ) {
      throw new Error(`FlowSpec "${flow.meta.id}" invalido: step.type nao suportado.`);
    }

    if (!Array.isArray(step.riskSignals)) {
      throw new Error(`FlowSpec "${flow.meta.id}" invalido: step.riskSignals deve ser array.`);
    }

    if (step.type === "question") {
      if (!isString(step.question)) {
        throw new Error(`FlowSpec "${flow.meta.id}" invalido: question obrigatoria.`);
      }
      if (!Array.isArray(step.actions) || step.actions.length === 0) {
        throw new Error(`FlowSpec "${flow.meta.id}" invalido: question.actions obrigatorias.`);
      }
      for (const action of step.actions) {
        if (!isString(action.label) || !isString(action.next)) {
          throw new Error(
            `FlowSpec "${flow.meta.id}" invalido: actions exigem label e next.`
          );
        }
      }
    }
  }

  for (const outcome of flow.outcomes) {
    if (!outcome || !isString(outcome.id)) {
      throw new Error(`FlowSpec "${flow.meta.id}" invalido: outcome.id obrigatorio.`);
    }
    if (!isString(outcome.label) || !isString(outcome.description)) {
      throw new Error(`FlowSpec "${flow.meta.id}" invalido: outcome label/description obrigatorios.`);
    }
    if (!Array.isArray(outcome.actions)) {
      throw new Error(`FlowSpec "${flow.meta.id}" invalido: outcome.actions deve ser array.`);
    }
    if (!isString(outcome.timeline)) {
      throw new Error(`FlowSpec "${flow.meta.id}" invalido: outcome.timeline obrigatorio.`);
    }
  }
}

function extractGeneratedSpecs(): FlowSpecV2[] {
  return Object.entries(flowRegistry)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([, spec]) => spec as unknown as FlowSpecV2);
}

function validateFlowRelations(flows: Flow[], categorySubIndex: Map<string, Set<string>>): void {
  const seenFlowIds = new Set<string>();

  for (const flow of flows) {
    const flowId = flow.meta.id;

    if (seenFlowIds.has(flowId)) {
      throw new Error(`Flows invalidos: flowId duplicado "${flowId}".`);
    }
    seenFlowIds.add(flowId);

    const subIds = categorySubIndex.get(flow.meta.categoryId);
    if (!subIds) {
      throw new Error(
        `Flow "${flowId}" invalido: categoryId "${flow.meta.categoryId}" nao existe em categories.json.`
      );
    }

    if (!subIds.has(flow.meta.subcategory)) {
      throw new Error(
        `Flow "${flowId}" invalido: subcategoryId "${flow.meta.subcategory}" nao existe na categoria "${flow.meta.categoryId}".`
      );
    }
  }
}

function validateExtensionsShape(): void {
  if (!isRecord(emergencyData)) {
    throw new Error("src/data/v2/emergency.json invalido: esperado objeto.");
  }

  if (!isRecord(heuristicsData)) {
    throw new Error("src/data/v2/heuristics.json invalido: esperado objeto.");
  }

  const servicesPayload = servicesData as ServicesPayload;
  if (!servicesPayload || !Array.isArray(servicesPayload.services)) {
    throw new Error('src/data/v2/services.json invalido: esperado objeto com array "services".');
  }
}

function mergeAndValidateSpecs(): FlowSpecV2[] {
  const registry = flowSpecRegistry as SpecRegistry;
  if (!Array.isArray(registry.flows)) {
    throw new Error("docs/domain/flows-v2-spec.json invalido: flows deve ser array.");
  }

  const generated = extractGeneratedSpecs();

  const byId = new Map<string, FlowSpecV2>();
  generated.forEach((spec, index) => {
    validateFlowSpec(spec, index);

    if (byId.has(spec.meta.id)) {
      throw new Error(`FlowSpec duplicado: "${spec.meta.id}".`);
    }
    byId.set(spec.meta.id, spec);
  });


  if (registry.flows.length !== 39) {
    throw new Error(`Registry invalido: esperado 39 flows oficiais, recebido ${registry.flows.length}.`);
  }

  for (const row of registry.flows) {
    const spec = byId.get(row.id);
    if (!spec) {
      throw new Error(`Flow sem spec detalhada: "${row.id}".`);
    }

    if (spec.meta.categoryId !== row.categoryId) {
      throw new Error(`Flow "${row.id}" com categoryId divergente do registry.`);
    }

    if (spec.meta.subcategoryId !== row.subcategoryId) {
      throw new Error(`Flow "${row.id}" com subcategoryId divergente do registry.`);
    }

    if (spec.meta.status !== row.status) {
      throw new Error(`Flow "${row.id}" com status divergente do registry.`);
    }

    if (spec.meta.severity !== row.severity) {
      throw new Error(`Flow "${row.id}" com severity divergente do registry.`);
    }
  }

  return registry.flows.map(row => byId.get(row.id) as FlowSpecV2);
}

export function composeModelV2(): AppModel {
  validateExtensionsShape();

  const parsedCategories = parseCategories(categoriesData);
  const specs = mergeAndValidateSpecs();
  const categories = buildCategoriesFromRegistry(
    parsedCategories,
    (flowSpecRegistry as SpecRegistry).flows
  );
  const categorySubIndex = buildCategorySubIndex(categories);
  const flows = specs.map(spec => {
    const runtimeV2 = buildRuntimeV2ById(spec.meta.id);
    return toLegacyFlow(runtimeV2);
  });

  validateFlowRelations(flows, categorySubIndex);

  const base = buildBaseModelV2();

  return {
    version: "1.0.0",
    ...base,
    categories,
    services: (servicesData as ServicesPayload).services as Service[],
    flows,
  } as AppModel;
}
